package com.samsung.tcm.core.loc;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * This class contains all the common file I/O operations. Functions in this
 * class are static so they can be called directly without instantiating an
 * object of this class.
 *
 * @author Integrity Applications Incorporated
 */
public class FileUtils {
    /**
     * Instantiate the Log4j logger for this class
     */
    private static final Logger logger = LogManager.getLogger(FileUtils.class);

    /**
     * Generates a list of files residing at the given directory path. This
     * function looks through sub-directories recursively and includes their
     * files names in the list.
     *
     * @param path     Path of directory this method generates a list of files for
     * @param fileList A list of files at the given directory path generated by this
     *                 function
     */
    public static void GenerateFileList(String path, ArrayList<String> fileList) {
        // Allocate memory for file list if it has not been allocated yet
        if (fileList == null) {
            fileList = new ArrayList<String>();
        }

        // Get the file object for the given path
        File root = new File(path);
        File[] list = root.listFiles();

        /**
         * Recursively generates file list in @path directory
         */
        if (list != null) {
            for (File f : list) {
                if (f.isDirectory()) {
                    GenerateFileList(f.getAbsolutePath(), fileList);
                } else {
                    fileList.add(f.getAbsoluteFile().toString());
                }
            }
        } else {
            System.err.println("No files found at directory path: " + path + " . Exiting the program.");
            logger.fatal("No files found at directory path: " + path + " . Exiting the program.");
            System.exit(1);
        }
    }

    /**
     * Generates a list of files residing at the given directory path. This
     * function looks through sub-directories recursively and includes their
     * files names in the list. All file names are filtered based on the provided
     * file filters. If no file filters are provided, all files at the given
     * directory path are included.
     *
     * @param path        Path of directory this method generates a list of files for
     * @param fileFilters A list of filters to be applied to files
     * @param fileList    A list of files at the given directory path generated by this
     *                    function
     */
    //Modified 2016.03 Fall for the implementation of -nolinks switch had to pass another fourth variable isSkipSymbolicLinks
    public static void GenerateFilteredFileList(String path, ArrayList<String> fileFilters, ArrayList<String> fileList, boolean isSkipSymbolicLinks) {
        Matcher matcher;
        String regEx;

        // Allocate memory for file list if it has not been allocated yet
        if (fileList == null) {
            fileList = new ArrayList<String>();
        }

        // Get the file object for the given path
        File root = new File(path);
        File[] list = root.listFiles();

        /**
         * Recursively generates file list in @path directory
         */
        if (list != null) {
            for (File f : list) {
                //Added 2016.03 Fall for ensuring that symlinks to files are counted if -nolinks switch not specified and otherwise ignored
                boolean isSymbolicLink = Files.isSymbolicLink(f.toPath());
                if (f.isDirectory()) {
                    if (isSymbolicLink && isSkipSymbolicLinks)
                        continue;
                    GenerateFilteredFileList(f.getAbsolutePath(), fileFilters, fileList, isSkipSymbolicLinks);
                } else {
                    // Get the file name
                    String fileName = f.getName();

                    // If file filters are available, apply them to the file name
                    if (fileFilters != null && !fileFilters.isEmpty()) {
                        for (int i = 0; i < fileFilters.size(); i++) {
                            // Replace wild card characters with Java regular
                            // expression characters
                            regEx = fileFilters.get(i).replace("?", ".?").replace("*", ".*");

                            try {
                                matcher = Pattern.compile(regEx).matcher(fileName);

                                // Check if file name contains filter pattern
                                if (matcher.matches()) {
                                    // Add full file path to the list
                                    fileList.add(f.getAbsoluteFile().toString());
                                    break;
                                }
                            } catch (PatternSyntaxException ex) {
                                logger.error("Invalid file filter \"" + fileFilters.get(i) + "\", could not form "
                                        + "regular expression with it."
                                        + "  Removing the file filter from the list of filters.");
                                logger.debug(ex);

                                // Remove the filter that is throwing the exception to
                                // prevent future exceptions and to proceed
                                // with the program
                                fileFilters.remove(i);

                                // Decrement index variable if there are other filters
                                // after it so they can be applied
                                if (i + 1 <= fileFilters.size()) {
                                    i--;
                                }
                            }
                        }
                    } else {
                        //Added 2016.03 Fall for ensuring that symlinks to files are counted if -nolinks switch not specified and otherwise ignored

                        if (isSymbolicLink && isSkipSymbolicLinks)
                            continue;
                        if (isSymbolicLink && !isSkipSymbolicLinks) {
                            Path link = f.toPath();
                            try {
                                Path t = Files.readSymbolicLink(link);
                                String s = t.toString();
                                fileList.add(s);
                            } catch (IOException x) {
                                System.err.println(x);
                            }
                        } else {
                            fileList.add(f.getAbsoluteFile().toString());

                        }
                    }
                }
            }
        } else {
            System.err.println("No files found at directory path: " + path + " . Exiting the program.");
            logger.fatal("No files found at directory path: " + path + " . Exiting the program.");
            System.exit(1);
        }
    }

    /**
     * Validates a given path as a directory. If the directory does not exist,
     * create it.
     *
     * @param path Directory path
     * @return True if directory at given path is a valid directory. False,
     * otherwise.
     */
    public static boolean ValidateDir(String path) {
        boolean valid = false;
        File dir = new File(path);

        try {
            // Check if the directory already exists
            if (dir.exists()) {
                // If it does, verify that it is a directory
                if (dir.isDirectory()) {
                    valid = true;
                }
            } else {
                // If the directory does not exist, create it and any other
                // directories necessary to get the complete path
                if (dir.mkdirs()) {
                    valid = true;
                }
            }
        } catch (SecurityException se) {
            System.err.println("Security Exception thrown while validating " + "directory path: " + path
                    + " . Exiting the program.");
            logger.fatal("Security Exception thrown while validating " + "directory path: " + path
                    + " . Exiting the program.");
            logger.debug(se);
            System.exit(1);
        }

        return valid;
    }

    /**
     * Verify the user provided file list by going through each entry in the
     * list. If an entry is a directory, add files in the directory to the list.
     *
     * @param fileListName     Name of file containing a list of files/directories
     * @param verifiedFileList A verified list of files that only contains files
     * @return Returns true if file list is valid, false otherwise
     */
    public static boolean VerifyFileList(String fileListName, ArrayList<String> verifiedFileList) {
        //Scanner s;
        boolean valid = true;

        try {
            LineNumberReader reader = new LineNumberReader(new InputStreamReader(
                    new FileInputStream(fileListName), Constants.CHARSET_NAME));
            ArrayList<String> fileList = new ArrayList<String>();
            String line = null;

            // Read in the list pointed by the fileListName and save its entries if they are valid files
            if (reader != null) {
                // While there are lines in the file...
                while ((line = reader.readLine()) != null) {
                    fileList.add(line);
                }

                // Close the file stream
                reader.close();
            }

            // Iterate through the list...
            for (int i = 0; i < fileList.size(); i++) {
                File fileListEntry = new File(fileList.get(i));

                // If an entry is a file, add it to verified list
                if (fileListEntry.isFile()) {
                    verifiedFileList.add(fileListEntry.getAbsoluteFile().toString());
                }
                // If an entry is a directory, add all the files in the directory to
                // the verified list
                else if (fileListEntry.isDirectory()) {
                    GenerateFileList(fileListEntry.toString(), verifiedFileList);
                }
            }

            verifiedFileList = RemoveDuplicates(verifiedFileList);

            // Check if no valid files were found
            if (verifiedFileList == null || verifiedFileList.isEmpty()) {
                System.err.println("No valid files found for processing with UCC-G");
                logger.error("No valid files found for processing with UCC-G");
                valid = false;
            }
        } catch (IOException e) {
            System.err.println("Error reading file " + fileListName);
            logger.error("Error reading file " + fileListName);
            logger.debug(e);
            valid = false;
        }

        return valid;
    }

    /**
     * Returns the file extension of the given file name
     *
     * @param fileName File path
     * @return A String containing file extension
     */
    public static String GetFileExt(String fileName) {
        if (fileName != null && fileName.lastIndexOf('.') != -1) {
            // Find the last file extension in the given String and return it
            return fileName.substring(fileName.lastIndexOf('.'));
        } else {
            return "";
        }
    }

    /**
     * Returns the file name from the given file path
     *
     * @param filePath File path with file name at the end
     * @return A String containing file name only
     */
    public static String GetFileName(String filePath) {
        if (filePath != null) {
            return new File(filePath).getName();
        } else {
            return "";
        }
    }

    /**
     * Reads lines from a file into a String buffer where each entry corresponds
     * to a line in the file
     *
     * @param fileName Name of the file to read
     * @param lineBuf  String buffer to store file contents
     * @return True if the file was read successfully. False, otherwise
     */
    public static boolean ReadLines(String fileName, ArrayList<String> lineBuf) {
        String line;
        boolean success = false;

        if (lineBuf != null) {
            // Create new line reader
            LineNumberReader reader;
            try {
                reader = new LineNumberReader(new InputStreamReader(new FileInputStream(fileName), Constants.CHARSET_NAME));

                // Read lines till the end of the stream
                while ((line = reader.readLine()) != null) {
                    if (!line.trim().isEmpty()) {
                        lineBuf.add(line);
                    }
                    success = true;
                }
                if (reader != null) {
                    reader.close();
                }
            } catch (UnsupportedEncodingException e) {
                logger.error("UnsupportedEncodingException when reading file " + fileName);
                logger.debug(e);
            } catch (FileNotFoundException e) {
                logger.error("FileNotFoundException when reading file " + fileName);
                logger.debug(e);
            } catch (IOException e) {
                logger.error("IOException when reading file " + fileName);
                logger.debug(e);
            }
        }

        return success;
    }

    /**
     * Deletes the file with provided file name
     *
     * @param fileName File name of the file to be deleted
     * @return True if the file was successfully deleted. False otherwise.
     */
    public static boolean DeleteFile(String fileName) {
        boolean deleted = false;

        File file = new File(fileName);
        if (file != null) {
            try {
                deleted = file.delete();
            } catch (SecurityException se) {
                logger.error("Security exception: " + fileName + " file could not be deleted");
                logger.debug(se);
            }
        }

        return deleted;
    }

    /**
     * Function for removing duplicates from the verified file list.
     *
     * @param verifiedFileList ArrayList of filenames
     * @return ArrayList of filenames with duplicates removed
     */
    public static ArrayList<String> RemoveDuplicates(ArrayList<String> verifiedFileList) {
        Set<String> lhs = new LinkedHashSet<>(verifiedFileList);
        lhs.addAll(verifiedFileList);
        verifiedFileList.clear();
        verifiedFileList.addAll(lhs);

        return verifiedFileList;
    }

    public static void CheckForDuplicateFileNames(ArrayList<UCCFile> cntrResults) {
        String filenameA;
        String filenameB;

        for (int fn1 = 0; fn1 < cntrResults.size(); fn1++) {
            for (int fn2 = 0; fn2 < cntrResults.size(); fn2++) {
                if (fn1 != fn2 && cntrResults.get(fn1).UniqueFileName && cntrResults.get(fn2).UniqueFileName) {
                    filenameA = GetFileName(cntrResults.get(fn1).FileName);
                    filenameB = GetFileName(cntrResults.get(fn2).FileName);
                    if (filenameA.equals(filenameB)) {
                        cntrResults.get(fn1).UniqueFileName = false;
                        cntrResults.get(fn2).UniqueFileName = false;
                    }
                }
            }
        }
    }
}
